# phone lighting
本笔记基于`phone_lighting_18.cpp`,与之前的代码相比移除掉了texture，代码结构更加简洁

# 代码流程
1. 内存中初始化两个shader对象与一系列顶点，其中
   - lightingShader:代表光照shader,用于被光照亮的cube
   - lightCubeShader:代表光源shader,用于光源这个立方体的渲染
   - vertices:代表立方体的顶点，每6个顶点为一组，一共六组，代表立方体的六个面，每一组代表立方体一个面的两个三角形，所以每一组有6个顶点。而前三个是坐标，后三个是这个顶点的法向量，注意是局部坐标的法向量。

2. 为被照的方块定义一个VBO与VAO，先将VBO与顶点数据绑定，再绑定VAO与VBO，再告诉显存如何解析顶点数据
3. 为光源方块定义一个VAO，因为想要共享VBO里面的顶点数据，所以直接绑定这个VAO与VBO即可，因为VBO才是存储数据的基础（先bind VAO，后bind VBO）。后面不用再将VBO与顶点数据绑定，直接告诉显存如何解析顶点数据即可。
4. 渲染循环：
   - lightingShader里的uniform设置好对象颜色、接收的光照颜色、光源位置、视线位置，其中视线位置通过camera获取；还有变换矩阵
   - 渲染cube的VAO
   - lightCubeShader里的uniform设置好变换矩阵即可
   - 渲染光源cube的VAO


# 小结
1. 在每个渲染循环里，每一帧都会根据鼠标与键盘，通过camera对象不断更新变换矩阵参数
2. 顶点着色器的输出是每个顶点处理后的位置，输出的gl_Position应当是原始数据经过一系列model、view、projection变换得到
3. 片段着色器的输出FragColor是每个采样点的颜色（可能是每像素一个采样点，可能是每像素四个采样点等），而每个采样点的计算：
- 如果FragColor只是单纯的设置一个颜色值，最终渲染就是统一的一个颜色值
- 如果FragColor是个关于texture与每个顶点uv坐标的函数，输出的每个像素会自动对uv坐标进行插值
- 如果FragColor是每个顶点对应的颜色，那么根据这句话
>当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。

  上面所说的决定这些片段的位置，应该是opengl自动计算的，而有了这些片段的位置，也就有了这个片段的颜色所应当占有的每个顶点的比重，就会自动计算出来了。因此，虽然片段着色器表面上是输出的每个顶点的颜色值，实际上opengl自动计算了每个像素的位置，计算出了每个像素的颜色值。

- 如果片段着色器接收的是FragPos这样的东西，而FragPos是根据顶点着色器若干顶点进行的变换，根据上一条，可以推测出实际上的FragPos指的就是每个像素所在的位置，opengl给自动插值了，而并非单纯的就是顶点的位置。而有了FragPos，我们就可以进行phone模型的计算了。
4. 根据上面的结论，就可以理解为什么我把phone模型的计算放在顶点着色器会造成Gouraud着色而不是冯氏着色了。
5. phone光照的计算，不管在世界空间还是相机空间计算都一样，只需要把变换做对就行。